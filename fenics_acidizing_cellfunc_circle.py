# -*- coding: utf-8 -*-
"""FEniCS_Acidizing_CellFunc_Circle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_QamDR9nRAi6YCf5LGDyVS3TnwzjvRks

# Startup: Installation and Configuration of FEniCS
"""

try:
    import dolfin
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/fenics-install-release-real.sh" -O "/tmp/fenics-install.sh" && bash "/tmp/fenics-install.sh"
    import dolfin

"""#Weak and Variational Formulations - Mathematical Derivations
---
Stoke-Darcy, continuity, conservation, change of porosity are described by Eqs. (1-4), respectively.

$$\frac{\mu}{\phi}\nabla^{2}u = \nabla P + \frac{\mu}{K}u \tag{1}$$

$$\frac{\partial \phi}{\partial t}+\nabla \cdot u = 0 \tag{2}$$

$$\frac{\partial (C\phi)}{\partial t}+\nabla\cdot(uC)-\nabla\cdot(\phi D\nabla C)+a_v k_e C = 0 \tag{3}$$

$$\frac{\partial \phi}{\partial t}=a_v k_e \beta \frac{\rho_{f}}{\rho _{m}} C \tag{4}$$

where,

$\mu=$ dynamic viscosity (*1 Pa$\cdot$sec=1000 cp*)

$\phi=$ porosity (*fraction*)

$u=$ velocity (*1 m/sec = 6,000 cm/min*)

$P=$ pressure (*Pa*)

$K=$ permeability (*1 m$^2$ = 10$^{15}$ mD*)

$t=$ time (*sec*)

$C=$ concentratoin (*mass fraction*)

$D=$ effective diffusivity coefficient (*m$^2$/sec*)

$a_{v}=$ specific surface area (*m$^{-1}$*)

$k_{e}=$ effective reaction rate constant (*m/sec*)

$\beta=$ acid gravimetric dissolving power (*dimensionless*)

$\rho_{f}=$ fluid density (*kg/m$^2$*)

$\rho_{m}=$ rock mineral density (*kg/m$^2$*)

---
Substituting Eq. (4) into Eq. (2), we have
$$\nabla \cdot u + a_v k_e \beta \frac{\rho_{f}}{\rho _{m}} C = 0 \tag{5}$$

$a_v$ and $k$ evol with the porosity based on their reference value $a_{v0}$, $k_0$ and $\phi_{0}$, as shown in Eqs. (6-7).

$$a_v=a_{v0} \left[ \left( \frac{\phi_0}{\phi} \right) \left( \frac{1-\phi}{1-\phi_0} \right) \right] \tag{6}$$

$$K=K_{0} \left[ \left( \frac{\phi}{\phi_0} \right) ^3 \left( \frac{1-\phi_0}{1-\phi} \right)^2 \right]^6 \tag{7}$$

---

Defining test functions $tf_1$, $tf_2$ and $tf_3$ for Eq.(1), Eq.(3) and Eq.(5), respectively, to construct variational formulatoins for solving unknowns $u$, $P$ and $C$. Other variable parameters $\phi$, $K$ and $a_v$ will be updated thereafter.

The integration of weak formulation of Eq.(1) is
$$\int_\Omega \frac{\mu}{\phi}\nabla^{2}u\cdot tf_1dx = \int_\Omega \nabla P \cdot tf_1dx + \int_\Omega \frac{\mu}{K}u\cdot tf_1dx \tag{8}$$

Since,
\begin{align}
\int_\Omega \frac{\mu}{\phi}\nabla\cdot (\nabla u\cdot tf_1)dx&=\int_\Gamma \frac{\mu}{\phi} \nabla u\cdot tf_1 \cdot \vec{n} ds\\
       &= \int_\Omega \frac{\mu}{\phi}\nabla^{2}u\cdot tf_1dx + \int_\Omega \frac{\mu}{\phi}\nabla u\cdot \nabla tf_1dx
\end{align}

we have
$$\int_\Omega \frac{\mu}{\phi}\nabla^{2}u\cdot tf_1dx = -\int_\Omega \frac{\mu}{\phi}\nabla u\cdot \nabla tf_1dx + \int_\Gamma \frac{\mu}{\phi} \nabla u\cdot tf_1 \cdot \vec{n} ds \tag{9}$$

Substituting Eq.(9) into Eq.(8) yields Eq.(10).
$$\int_\Omega \frac{\mu}{\phi}\nabla u\cdot \nabla tf_1dx + \int_\Omega \nabla P \cdot tf_1dx + \int_\Omega \frac{\mu}{K}u\cdot tf_1dx = 0\tag{10}$$

The corresponding variational formulation of Eq.(10) is
```
F1 = mu/Porosity*inner(grad(u),grad(tf1))*dx \
    + inner(grad(P),tf1)*dx \
    + mu/Permeability*inner(u,tf1)*dx \
```
---
The weak and variational formulations of Eq.(5) are
$$\int _\Omega \nabla \cdot u tf_2 dx + \int _\Omega a_v k_e \beta \frac{\rho_{f}}{\rho _{m}} C tf_2 dx = 0 \tag{11a}$$
```
F2 = div(u)*tf2*dx + Avo*beta100*k_s*rho_f/rho_m*C*tf2*dx
```
or $$\int_\Omega \nabla \cdot (u \cdot tf_2)dx = \int _\Gamma u \cdot \vec{n} \cdot tf_2ds  = \int_\Omega \nabla \cdot u \cdot tf_2dx + \int_\Omega \nabla tf_2 \cdot u dx$$

Therefore, Eq. (11a) is rederived as Eq. (11b) where of boundary condition of constant flux $u \cdot \vec{n}$ can be implemented.
$$\int_\Omega \nabla tf_2 \cdot u dx - \int _\Omega a_v k_e \beta \frac{\rho_{f}}{\rho _{m}} C tf_2 dx = \int _\Gamma u \cdot \vec{n} \cdot tf_2ds \tag{11}$$

---
Implementing chain rule over Eq.(3) yields,

$$C\frac{\partial \phi}{\partial t}+\phi\frac{\partial C}{\partial t}+\nabla\cdot u C +\nabla C \cdot u  -\nabla\cdot(\phi D\nabla C)+a_v k_e C = 0 \tag{12}$$

According to Eq.(2), we have
$$C\frac{\partial \phi}{\partial t}+\phi\frac{\partial C}{\partial t}+C\nabla\cdot u +\nabla C \cdot u = \phi\frac{\partial C}{\partial t}+\nabla C \cdot u \tag{13}$$

Eq.(12) therefore becomes
$$\phi\frac{\partial C}{\partial t}+\nabla C \cdot u -\nabla\cdot(\phi D\nabla C)+a_v k_e C = 0 \tag{14}$$

The weak formulation of Eq.(14) is
$$\int _\Omega\phi\frac{\partial C}{\partial t}tf_3 dx + \int _\Omega \nabla C \cdot u tf_3 dx - \int _\Omega \nabla\cdot(\phi D\nabla C) tf_3 dx + \int _\Omega a_v k_e C (tf_3) dx = 0 \tag{15}$$

Considering
\begin{align}
\int _\Omega \nabla\cdot(\phi D\nabla C tf_3) dx &=\int_\Gamma \phi D \nabla C \cdot \vec{n} tf_3 ds\\ \\
       &= \int _\Omega \nabla\cdot(\phi D\nabla C) tf_3 dx + \int _\Omega \phi D \nabla tf_3 \cdot \nabla C dx
\end{align}
and implementing non-diffusible boundaries, Eq.(15) becomes,

$$\int _\Omega\phi\frac{\partial C}{\partial t}tf_3 dx + \int _\Omega \nabla C \cdot u tf_3 dx + \int _\Omega \phi D \nabla tf_3 \cdot \nabla C dx + \int _\Omega a_v k_e C (tf_3) dx = 0 \tag{16}$$

```
F3 = (Ctf-C_n)*Porosity/dt*tf3*dx \
    + dot(u,grad(C))*tf3*dx \
    + D*Porosity*dot(grad(tf3),grad(C))*dx \
    + Avo*k_s*C*tf3*dx
```
---


<!-- \ref{eqn:somelabel} -->

#Decoupled Solution Code in FEniCS with Cell Function $\phi$, $K$ and $a_v$

##Step 1: Import libs and define simulation parameters and properties
"""

from fenics import *
from mshr import *
import numpy as np
from datetime import date
import sys
import random
import math
from statistics import mean



#Initial and Boundary Condition
u_inlet = 5E-3    #0.000167*1000             #m/sec (1 m/sec = 6000 cm/min)
C_inlet = 0.22     #4.320  #0.02       #0.28                     #mol/m3   #mass fraction

#Simulation Parameters

T = int(1E10)
num_steps = int(1E10)

#dt = T/num_steps

dt = 0.1/u_inlet

#num_steps = int(T/dt)



#Rock and Fluid Properties
D = Constant(3.6E-9)  #Constant(3E-9)   #Constant(1E-9)    #m2/sec
mu = Constant(0.001)  #Constant(0.005)                     #pa-sec (1 pa-sec = 1000 cp)
poro_ref =  0.2       #0.1                                 #fraction
perm_ref = 1E-15      #1.5E-15                             #m2 (1 mD = 1E-15 m2)
rho_f = 1140          #1050                                #kg/m3
rho_m = 2710          #2650                                #kg/m3
beta100 = 1.37                      #fraction   #kg/mol
k_s = 0.000252            #0.01               #m/s
r_po0 = 1E-6           #0.00001            #m
a_v0 =  14.286        #100                #1/m

print("Completed!")
today = date.today()
print("Today's date:", today)

"""##Step 2: Generate finite element mesh system and add fractures"""

# Create a computational domain
#DimX = 1
#DimY = 1
#domain = Rectangle(Point(0,0), Point(DimX,DimY))

r_domain = 1     #0.2   #2    #1
r_well =   0.1   #0.02  #0.2  #0.1
center_x = 0
center_y = 0

domain = Circle(Point(center_x,center_y),r_domain) - Circle(Point(center_x,center_y),r_well)

# Create a subdomain for fractures (each frac is a rectangle)
def createFracSubDomain (fracdata):
  fracdomain = []

  for i in range (0, len(fracdata)):
    L = fracdata[i][0]      # the length of your rectangle
    b = fracdata[i][1]      # aperture
    a = fracdata[i][2]      # orientation angle
    Cx = fracdata[i][3]     # center point x
    Cy = fracdata[i][4]     # center point y

    # coordinate of each corner point for rectangle with the center at (0,0)
    LeftTop_x = -L/2; LeftTop_y = b/2; LeftBot_x = -L/2; LeftBot_y = -b/2
    RightBot_x = L/2; RightBot_y = -b/2; RightTop_x = L/2; RightTop_y = b/2

    #The rotated position of each corner
    Rx1 = Cx + (LeftTop_x  * math.cos(a)) - (LeftTop_y * math.sin(a))
    Ry1 = Cy + (LeftTop_x  * math.sin(a)) + (LeftTop_y * math.cos(a))
    Rx2 = Cx + (LeftBot_x  * math.cos(a)) - (LeftBot_y * math.sin(a))
    Ry2 = Cy + (LeftBot_x  * math.sin(a)) + (LeftBot_y * math.cos(a))
    Rx3 = Cx + (RightBot_x  * math.cos(a)) - (RightBot_y * math.sin(a))
    Ry3 = Cy + (RightBot_x  * math.sin(a)) + (RightBot_y * math.cos(a))
    Rx4 = Cx + (RightTop_x  * math.cos(a)) - (RightTop_y * math.sin(a))
    Ry4 = Cy + (RightTop_x  * math.sin(a)) + (RightTop_y * math.cos(a))

    domain_vertices = [Point(Rx1,Ry1),Point(Rx2,Ry2),Point(Rx3,Ry3),Point(Rx4,Ry4),Point(Rx1,Ry1)]

    if i == 0:
      fracdomain = Polygon(domain_vertices)
    else:
      fracdomain = fracdomain + Polygon(domain_vertices)

  return fracdomain

# generate fracture subdmain based on fracture data
#fracdata = [length, aperture, angle, center_x, center_y]

Length = 0.3
fracwidth = 0.01
ang = 2.36

fracdata = [
             # default
            #[Length,fracwidth, -0.7, 0.2, 0.6],
            #[Length,fracwidth,0.7, 0.5, 0.3],
            #[Length,fracwidth, -0.7, 0.7, 0.5],
            #[Length,fracwidth, 0.7, 0.2, -0.25],
            #[Length,fracwidth, -0.7, 0.7, -0.15],
            #[Length,fracwidth, -0.7,  0.25, -0.65],
            #[Length,fracwidth, 0.7,  -0.7, -0.18],
            #[Length,fracwidth, 0.7,  -0.25, -0.70],
            #[Length,fracwidth, -0.7, -0.5, -0.45],
            #[Length,fracwidth, -0.7,  -0.7, 0.55],
            #[Length,fracwidth, -0.7,  -0.35, 0.0],
            #[Length,fracwidth, 0.6, -0.3, 0.5]

            # for fracture orientation case
            [Length,fracwidth, ang, 0.2, 0.6],
            [Length,fracwidth, ang, 0.5, 0.2],
            [Length,fracwidth, ang, 0.65, 0.65],
            [Length,fracwidth, ang, 0.35, -0.25],
            [Length,fracwidth, ang, 0.7, -0.15],
            [Length,fracwidth, ang,  0.25, -0.65],
            [Length,fracwidth, ang,  -0.7, -0.10],
            [Length,fracwidth, ang,  -0.3, -0.8],
            #[Length,fracwidth, ang, -0.4, -0.45],#not for 2.36 rad or 135 degree
             [Length,fracwidth, ang, -0.2, -0.2], # updated
            #[Length,fracwidth, ang,  -0.6, 0.4], #not for 2.36 rad or 135 degree
             [Length,fracwidth, ang,  -0.6, 0.25],#updated
            #[Length,fracwidth, ang,  -0.3, 0.2], #not for 2.36 rad or 135 degree
             [Length,fracwidth, ang,  -0.3, 0.4], # updated
            [Length,fracwidth, ang, -0.25, 0.7]
           ]


fracdomain = createFracSubDomain (fracdata)

# Add fractures into the domain and mark them as subdomain '1'
domain.set_subdomain(1, fracdomain)

# Generature mesh for the combined system
mesh = generate_mesh(domain, 50)

print("number of element :", mesh.num_cells())

# Create a cell list for fractures -> frac_cells
domains = mesh.domains()
subdomains = MeshFunction('size_t',mesh,2,domains)
frac_cells = SubsetIterator(subdomains, 1)

plot(mesh)

"""##Step 3: Define finite element function space, trial/test functions and initialize varialbes"""

# Define function spaces and mixed (product) space
scalar = FiniteElement("CG", mesh.ufl_cell(), 1)
vector = VectorElement("CG", mesh.ufl_cell(), 2)
W = FunctionSpace(mesh, MixedElement(vector, scalar))

# Define trial and test functions
(u, P) = TrialFunctions(W)
(tf1, tf2) = TestFunctions(W)

# Define trial and test functions for C
CFS = FunctionSpace(mesh, "CG", 1)
Ctf = TrialFunction(CFS)
tf3 = TestFunction(CFS)
C = Function(CFS)
C_n = Function(CFS)

#C = project(Constant(0.0), CFS)
C_n = project(Constant(0.0), CFS)

#Initialize Properties and Generate Cell Functions for Properties
poro = MeshFunction("double", mesh, 2)
perm = MeshFunction("double", mesh, 2)
a_v = MeshFunction("double", mesh, 2)
for cell in cells(mesh):
    poro[cell] = random.gauss(poro_ref, 0.02) #0.01
    perm[cell] = perm_ref*pow(pow(poro[cell]/poro_ref,3)*pow((1-poro_ref)/(1-poro[cell]),2),6)
    a_v[cell] = a_v0*pow(poro_ref/poro[cell]*(1-poro[cell])/(1-poro_ref),1)

#update properties in fracture cells
for cell in frac_cells:
    poro[cell] = 0.9999999
    perm[cell] = perm_ref*pow(pow(poro[cell]/poro_ref,3)*pow((1-poro_ref)/(1-poro[cell]),2),6)
    a_v[cell] = a_v0*pow(poro_ref/poro[cell]*(1-poro[cell])/(1-poro_ref),1)

# Define Properties Functions and Initialize###############################
plot(poro)
print(max(poro.array()[:]),min(poro.array()[:]))
print(max(perm.array()[:]),min(perm.array()[:]))
print(max(a_v.array()[:]),min(a_v.array()[:]))

def calculatePV(poro, mesh):
  PV = 0
  for cell in cells(mesh):
    PV = PV + poro[cell]*cell.volume()

  return PV

Pore_volume = calculatePV(poro, mesh)

Pore_volume = Pore_volume + 12*(Length*fracwidth)

print("pore volume ", Pore_volume )



# Code for C++ evaluation of conductivity
property_code = """

#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>
namespace py = pybind11;

#include <dolfin/function/Expression.h>
#include <dolfin/mesh/MeshFunction.h>

class Property : public dolfin::Expression
{
public:

  // Create expression with 3 components
  Property() : dolfin::Expression(3) {}

  // Function for evaluating expression on each cell
  void eval(Eigen::Ref<Eigen::VectorXd> values, Eigen::Ref<const Eigen::VectorXd> x, const ufc::cell& cell) const override
  {
    const uint cell_index = cell.index;
    values[0] = (*c0)[cell_index];
    values[1] = (*c1)[cell_index];
    values[2] = (*c2)[cell_index];
  }

  // The data stored in mesh functions
  std::shared_ptr<dolfin::MeshFunction<double>> c0;
  std::shared_ptr<dolfin::MeshFunction<double>> c1;
  std::shared_ptr<dolfin::MeshFunction<double>> c2;

};

PYBIND11_MODULE(SIGNATURE, m)
{
  py::class_<Property, std::shared_ptr<Property>, dolfin::Expression>
    (m, "Property")
    .def(py::init<>())
    .def_readwrite("c0", &Property::c0)
    .def_readwrite("c1", &Property::c1)
    .def_readwrite("c2", &Property::c2);
}

"""

c = CompiledExpression(compile_cpp_code(property_code).Property(),
                       c0=poro, c1=perm, c2=a_v, degree=0)

Phi = c[0]
K = c[1]
A_v = c[2]



"""##Step 4: Implement boundary conditions

"""

# Create functions for boundary conditions
zero   = Constant(0)

xmin=center_x-r_well-DOLFIN_EPS
xmax=center_x+r_well+DOLFIN_EPS
ymin=center_y-r_well-DOLFIN_EPS
ymax=center_y+r_well+DOLFIN_EPS

#Define boundary
def outerBD(x, on_boundary):
    return on_boundary and (x[0]*x[0]+x[1]*x[1]>0.2)

bcs = DirichletBC(W.sub(1), zero, outerBD)

print(xmin, xmax, ymin, ymax)
class BoundaryX0(SubDomain):
  def inside(self, x, on_boundary):
    #return on_boundary and (x[0] < DOLFIN_EPS and x[1] > DOLFIN_EPS and x[1] < DimY - DOLFIN_EPS)
    return on_boundary and (x[0]>xmin and x[0]<xmax and x[1]>ymin and x[1]<ymax)

bx0 = BoundaryX0()
boundaries = MeshFunction("size_t", mesh, 1)
boundaries.set_all(0)
bx0.mark(boundaries, 1)
ds = Measure('ds', domain = mesh, subdomain_data = boundaries)

#Set BC for Concentration
Cbc1 = DirichletBC(CFS, Constant(C_inlet), BoundaryX0())

print("Completed!")

"""##Step 5: Assemble variational formulations"""

f = Constant((0, 0))

a = mu/Phi*inner(grad(u),grad(tf1))*dx \
    + inner(grad(P),tf1)*dx \
    + mu/K*inner(u,tf1)*dx \
    + dot(grad(tf2),u)*dx #div(u)*tf2*dx
L = dot(f,tf1)*dx  + A_v*beta100*k_s*rho_f/rho_m*C_n*tf2*dx + (-u_inlet)*tf2*ds(1)# -A_v*beta100*k_s*rho_f/rho_m*C_n*tf2*dx

w = Function(W)

#Assemble Eq for C
(u, P) = w.split()

C_mid = Ctf#(Ctf+C_n)*0.5
F = (Ctf-C_n)*Phi*tf3*dx + dt*(tf3*dot(u,grad(C_mid))*dx \
     + D*Phi*dot(grad(tf3),grad(C_mid))*dx) + dt*Phi*A_v*k_s*C_mid*tf3*dx

#Residue
res = (Ctf-C_n)*Phi+dt*(dot(u,grad(C_mid))-D*Phi*div(grad(C_mid))) + dt*Phi*A_v*k_s*C_mid

# Add SUPG stabilisation terms
vnorm = sqrt(dot(u, u))
h = 2*Circumradius(mesh)
delta = h/(2.0*vnorm)
F = F + delta*dot(u, grad(tf3))*res*dx

a1 = lhs(F)
L1 = rhs(F)

print("Completed!")

"""##Step 6: Define output difiles and start simulation"""

#defining output data files
from google.colab import drive
drive.mount('/content/drive', force_remount=True)


vtkfileC = File('/content/drive/My Drive/Data/Concentration.pvd')
#vtkfileP = File('/content/drive/My Drive/Data/Pressure.pvd')
#vtkfileV = File('/content/drive/My Drive/Data/Velocity.pvd')
vtkfilePhi = File('/content/drive/My Drive/Data/Porosity.pvd')
#vtkfileK = File('/content/drive/My Drive/Data/Permeability.pvd')

R_pressure = []
t = 0
for n in range (num_steps):
    t = t + dt
    Counter = 0
    pressure = []

    #update Properties#######################################
    for cell in cells(mesh):
      coord_celda = cell.get_vertex_coordinates()
      center_celda_x = (coord_celda[0] + coord_celda[2] + coord_celda[4])/3
      center_celda_y = (coord_celda[1] + coord_celda[3] + coord_celda[5])/3

      cp = (center_celda_x, center_celda_y)

      CinCell = C_n(cp)
      if CinCell < 0:
        CinCell = 0.0

      poro[cell] = poro[cell] + dt*a_v[cell]*beta100*rho_f/rho_m*k_s*CinCell
      if poro[cell] > 0.999999:
        poro[cell] = 0.999999
      perm[cell] = perm_ref*pow(pow(poro[cell]/poro_ref,3)*pow((1-poro_ref)/(1-poro[cell]),2),6)
      a_v[cell] = a_v0*pow(poro_ref/poro[cell]*(1-poro[cell])/(1-poro_ref),1)


    #poro.array()[:] = poro.array()[:] + dt*a_v.array()[:]*beta100*rho_f/rho_m*k_s*C_n.vector()[:]
    #poro.array()[poro.array() >= 0.99999999] = 0.99999999
    #perm.array()[:] = perm_ref*pow(pow(poro.array()[:]/poro_ref,3)*pow((1-poro_ref)/(1-poro.array()[:]),2),6)
    #a_v.array()[:] = a_v0*pow(poro_ref/poro.array()[:]*(1-poro.array()[:])/(1-poro_ref),1)

    solve(a == L, w, bcs)

    (u, P) = w.split()

    #1D decay decoupled procedure
    #tempA = project(Constant(0), CFS)
    #tempA.vector()[:] = -dt*A_v.vector()[:]*k_s*C_n.vector()[:]*Phi.vector()[:]
    #C_n.vector()[:] = C_n.vector()[:]*np.exp(tempA.vector()[:])
    #########

    solve(a1 == L1, C, Cbc1)

    #negative to zero
    C.vector()[:] = (C.vector()[:] + abs(C.vector()[:]))*0.5

    C_n.assign(C)

    if n==0 or (n+1)%2==0:
      #vtkfileP << (P, t)
      #vtkfileV << (u, t)
      vtkfileC << (C, t)
      vtkfilePhi << (poro, t)
      #vtkfileK << (K, t)

      #print ("t =", t, "/", T, "sec")

      for i in np.linspace(0,360,10):
        e = 0.0001

        point=((r_well+e)* math.sin(math.radians(i)),(r_well+e)*math.cos(math.radians(i)))

        #print(point)

        pressure.append(P(point))

      if mean(pressure)>= 0:

        #print(pressure)
        R_p = mean(pressure)

        R_pressure.append(R_p)

        print ("t = ", t,"secs  ",  R_p)

      if (R_pressure[-1] <= R_pressure[0]/100):
        break


#
PV_b = (u_inlet * 2*math.pi*r_well * t)/(Pore_volume)
#
plot(poro)

print("Pore volume at Breakthrough: ", PV_b)

print ("Simulation Completed!")